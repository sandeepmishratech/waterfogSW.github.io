---
layout: article
title:  "[C/C++] inline function"
excerpt: inline function에 대해 설명합니다.
categories:
  - C/C+++
tags:
  - C/C+++
cover: https://user-images.githubusercontent.com/28651727/124687580-23525080-df10-11eb-987b-9a5d97550718.png
---

Linux kernel의 코드를 보면 `static inline void ~`와 같은 형태로 함수가 선언되어 있는것을 볼 수 있습니다.

`inline`을 사용하게 되면 다음의 main 함수 코드가 
```cxx
void hello() {
    cout << "hello world" << endl;
}

void main() {
    hello();
}
```

다음과 같이 호출하는 함수가 해당함수의 코드가 됩니다.
```cxx
void main() {
    cout << "hello world" << endl;
}
```
기존 C언어의 매크로 함수와 비슷한 역할을 하지만 inline함수는 매크로 함수의 복잡한 선언 형태와 달리 함수의 식별자 앞에 inline만 붙이면 됩니다.

### inline 함수의 장점
1. 함수 호출로 인한 오버헤드가 없습니다.
2. 마찬가지로 함수를 호출할때 변수를 스택에 push/pop하는데 오버헤드가 없습니다.
3. 함수 return으로 인한 오버헤드가 없습니다.
4. instruction cache를 활용하여 참조 지역성을 높입니다.
   - 함수가 호출되면 CPU가 다른 레지스터와 함께 실행 중인 현재 명령어의 주소를 저장해야 하므로 성능 오버헤드가 발생합니다.
5. inline이 적용된 함수에 대해서는 컴파일러가 **프로시저간 최적화(IPO)**을 적용할 수 있게 됩니다.

> **IPO** <br>
> 프로시저 간 최적화(interprocedural optimization, IPO)는 중소 규모의 길이의 자주 사용되는 수많은 함수들을 포함하여 프로그램의 성능 개선을 위해 컴퓨터 프로그래밍에 사용되는 컴파일러 기법의 모임이다. IPO는 다른 컴파일러 최적화와는 다른데, IPO가 프로그램 전반을 분석하는 반면, 다른 최적화 기법들은 하나의 함수, 또는 하나의 코드 블록만 본다.
> 
>IPO는 중복 연산, 비효율적인 메모리 사용을 감소시키거나 제거하고 루프와 같은 반복적인 시퀀스를 단순케하는 방법을 강구한다. 루프 안에서 발생되는 다른 루틴으로의 호출이 있을 경우 IPO는 이를 인라인하는 것이 최적인지를 확인하고 결정할 수 있다. 게다가 IPO는 더 나은 메모리 레이아웃과 로컬리티를 위해 루틴을 재정렬할 수 있다.
>
>또, IPO는 전체 프로그램 수준에서 일반적인 컴파일러 최적화를 수행할 수도 있는데 이를테면 전혀 실행될 가능성이 없는 코드를 제거하는 죽은 코드 제거를 들 수 있다. 이를 수행하기 위해 컴파일러는 전혀 취하지 않은 브랜치에 대해 테스트하고 브랜치 안의 코드를 제거한다. 또, IPO는 더 나은 상수(constant)의 사용 보장을 시도한다. 현대의 컴파일러들은 컴파일 시간에 옵션으로서 IPO를 제공한다. 실제 IPO 프로세스는 인간이 읽을 수 있는 소스 코드와 완성된 실행 파일 바이너리 프로그램을 생성하는 과정 사이에서 발생할 수 있다.
>
> 출처 : https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80_%EA%B0%84_%EC%B5%9C%EC%A0%81%ED%99%94

### inline 함수의 단점
1. 함수의 길이가 캐시의 크기보다 커지게 되어 캐시 미스를 발생시킬 수 있습니다.
2. 인라인 함수의 활용으로 함수내 변수의 개수가 많아져 레지스터 변수자원 활용에 오버헤드를 발생시킬 수 있습니다. 
3. 헤더파일에 사용될경우 헤더파일의 크기를 크게만들어 가독성을 떨어뜨릴 수 있습니다.
4. 인라인 함수를 너무 많이 사용할 경우 코드의 크기가 너무 길어져 메모릐 thrashing을 유발할 수 있습니다. 이는 프로그램에 page fault를 발생시킬 가능성을 증가시켜 성능 저하의 원인이 됩니다.
5. 메모리 사용량을 증가시켜 메모리 사이즈가 제한된 임베디드 시스템에서 불리합니다. 

### inline 사용 가이드라인
1. inline사용으로 성능향상이 자명할때만 사용합니다
2. 매크로함수보다 inline함수를 사용합니다.
3. 코드길이가 짧은 함수에만 inline을 적용합니다. 코드 길이가 짧고 호출이 잦은 함수에 적용하면 좋습니다.
4. class의 메소드에 적용하고자 하는경우 함수 정의와 함께 class의 밖에서 적용하는것이 좋습니다.
5. 재귀함수의 경우 대부분의 컴파일러는 inline을 적용하지 않습니다 (단, visual c++컴파일러의 경우 재귀함수에 적용할 수 있도록 `pragma inline`을 제공합니다.)
