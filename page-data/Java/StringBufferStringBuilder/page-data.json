{"componentChunkName":"component---src-templates-blog-post-js","path":"/Java/StringBufferStringBuilder/","result":{"data":{"site":{"siteMetadata":{"title":"For The Record","author":"San Kim","siteUrl":"https://waterfogsw.github.io","comment":{"disqusShortName":"","utterances":"waterfogSW/waterfogSW.github.io"}}},"markdownRemark":{"id":"bf5c3599-ddbf-56c7-97b2-45c2586e4760","excerpt":"Goal StringBuilder와 StringBuffer의 차이 StringBuilder, StringBuffer StringBuilder, StringBuffer 둘다 mutable한 객체이며 데이터 변경이 빈번한 경우에 성능면에서 유리합니다. 하지만 둘사이에는 약간의 차이가 존재합니다. StringBuffer StringBuffer는 데이터 변경시 스레드간 동기화를 진행하기 때문에 때문에 thread-safe합니다. Synchronized Method 인스턴스 단위로 lock…","html":"<h3 id=\"goal\" style=\"position:relative;\"><a href=\"#goal\" aria-label=\"goal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Goal</h3>\n<ul>\n<li>StringBuilder와 StringBuffer의 차이</li>\n</ul>\n<h3 id=\"stringbuilder-stringbuffer\" style=\"position:relative;\"><a href=\"#stringbuilder-stringbuffer\" aria-label=\"stringbuilder stringbuffer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>StringBuilder, StringBuffer</h3>\n<ul>\n<li>StringBuilder, StringBuffer 둘다 mutable한 객체이며 데이터 변경이 빈번한 경우에 성능면에서 유리합니다. 하지만 둘사이에는 약간의 차이가 존재합니다.</li>\n</ul>\n<h3 id=\"stringbuffer\" style=\"position:relative;\"><a href=\"#stringbuffer\" aria-label=\"stringbuffer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>StringBuffer</h3>\n<ul>\n<li>\n<p>StringBuffer는 데이터 변경시 스레드간 동기화를 진행하기 때문에 때문에 thread-safe합니다.</p>\n<ul>\n<li>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token annotation punctuation\">@HotSpotIntrinsicCandidate</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token class-name\">StringBuffer</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    toStringCache <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>Synchronized Method</strong></p>\n<p>인스턴스 단위로 lock을 설정하며, 메서드가 시작될 때 부터 종료될 때 까지 동기화가 발생합니다. 동일 인스턴스 내의 다른 synchronized method에 대해서도 동일한 lock을 설정합니다.</p>\n</blockquote>\n<h3 id=\"stringbuilder\" style=\"position:relative;\"><a href=\"#stringbuilder\" aria-label=\"stringbuilder permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>StringBuilder</h3>\n<ul>\n<li>\n<p>반면 StringBuilder는 스레드간 동기화를 지원하지 않기 때문에 thread-safe하지 않으나, 단일 스레드에서의 성능은 StringBuffer보다 우수합니다.</p>\n<ul>\n<li>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token annotation punctuation\">@HotSpotIntrinsicCandidate</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">StringBuilder</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>이러한 차이때문에 StringBuilder의 주석에서는 다음과 같이 멀티 스레드 환경에서는 StringBuilder를 사용할것을 권장하고 있습니다.</li>\n<li>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">* Instances of {@code StringBuilder} are not safe for\n* use by multiple threads. If such synchronization is required then it is\n* recommended that {@link java.lang.StringBuffer} be used.</code></pre></div>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[Java] StringBuilder vs StringBuffer","date":"March 21, 2022"}}},"pageContext":{"slug":"/Java/StringBufferStringBuilder/","previous":{"fields":{"slug":"/Java/collectionFramework/"},"frontmatter":{"title":"[Java] Collection Framework"}},"next":{"fields":{"slug":"/CS/Factory/"},"frontmatter":{"title":"[Design Pattern]Factory Pattern"}}}}}