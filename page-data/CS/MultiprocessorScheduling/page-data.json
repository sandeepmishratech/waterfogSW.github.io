{"componentChunkName":"component---src-templates-blog-post-js","path":"/CS/MultiprocessorScheduling/","result":{"data":{"site":{"siteMetadata":{"title":"For The Record","author":"San Kim","siteUrl":"https://waterfogsw.github.io","comment":{"disqusShortName":"","utterances":"waterfogSW/waterfogSW.github.io"}}},"markdownRemark":{"id":"49e96d52-8f73-5a24-8274-e0b1a55028cc","excerpt":"CPU Cache 캐시는 용량이 작고, 빠른 특성때문에 자주사용되는 데이터를 주로 저장합니다 Temporal locality(시간 지역성) 마지막에 접근한 데이터를 다시 접근하는 특성을 말합니다. stack, for loop Spatial locality(공간 지역성) 접근한 데이터의 주변 데이터를 다시 접근하는 특성을 말합니다. Array, sequential execution …  Benefit Cache hit : 캐시에 담아놓은 데이터를 접근하게 되면 Cache hit…","html":"<h2 id=\"cpu-cache\" style=\"position:relative;\"><a href=\"#cpu-cache\" aria-label=\"cpu cache permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU Cache</h2>\n<ul>\n<li>\n<p>캐시는 용량이 작고, 빠른 특성때문에 자주사용되는 데이터를 주로 저장합니다</p>\n<ul>\n<li>Temporal locality(시간 지역성)</li>\n<li>마지막에 접근한 데이터를 다시 접근하는 특성을 말합니다.</li>\n<li>stack, for loop</li>\n<li>Spatial locality(공간 지역성)</li>\n<li>접근한 데이터의 주변 데이터를 다시 접근하는 특성을 말합니다.</li>\n<li>Array, sequential execution … </li>\n</ul>\n</li>\n<li>\n<p>Benefit</p>\n<ul>\n<li>Cache hit : 캐시에 담아놓은 데이터를 접근하게 되면 Cache hit, 담아놓지 않은 데이터를 접근하면 Cache miss가됩니다. Cache hit하게 되면 메모리보다 훨씬 빠른속도로 데이터에 접근할 수 있습니다.</li>\n<li>Delayed Write : 쓰기 작업시 바로 메모리에 접근하지 않고, 캐시에 쓰기작업을 한 후 메모리에 접근할 때 한번에 쓰기작업을 합니다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"cache-affinity\" style=\"position:relative;\"><a href=\"#cache-affinity\" aria-label=\"cache affinity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cache Affinity</h2>\n<ul>\n<li>CPU Cache는 job이 이전에 접근한 메모리를 저장해놓고있는데 Context Switch이후 캐시되어 있는 프로세서가 아닌 다른 프로세서에 스케줄링 되면 Cache miss로 인해 성능저하(Cache miss)가 발생할 수 있습니다.</li>\n<li>이를 방지하기 위해서 이전에 수행했던 프로세서에 스케줄링하여 Cache hit를 높이는것이 좋습니다.</li>\n</ul>\n<h3 id=\"sqmssingle-queue-multiprocessor-scheduling\" style=\"position:relative;\"><a href=\"#sqmssingle-queue-multiprocessor-scheduling\" aria-label=\"sqmssingle queue multiprocessor scheduling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQMS(Single Queue Multiprocessor Scheduling)</h3>\n<p>여러개의 코어를 하나의 큐로 스케줄링</p>\n<ul>\n<li>장점 : 구현이 간단하다, job이 공평하게 분배됨</li>\n<li>단점 : 공유자원인 큐에 대한 lock오버헤드 발생</li>\n</ul>\n<h3 id=\"mqmsmulti-queue-multiprocessor-scheduling\" style=\"position:relative;\"><a href=\"#mqmsmulti-queue-multiprocessor-scheduling\" aria-label=\"mqmsmulti queue multiprocessor scheduling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MQMS(Multi Queue Multiprocessor Scheduling)</h3>\n<p>각 코어마다 큐를 가지고 있음.</p>\n<ul>\n<li>장점 : Affinity가 좋다, lock으로 인한 오버헤드가 적다.</li>\n<li>단점 : load balancing을 고려해야 한다.</li>\n</ul>\n<h4 id=\"load-balancing부하균등\" style=\"position:relative;\"><a href=\"#load-balancing%EB%B6%80%ED%95%98%EA%B7%A0%EB%93%B1\" aria-label=\"load balancing부하균등 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Load balancing(부하균등)</h4>\n<ul>\n<li>각 CPU의 큐는 독립적이므로 서로의 상태를 알지 못한다.</li>\n<li>스케줄러는 가장 여유로운 큐를 Source큐로 선택, 임의 선택된 Target큐가 Source큐보다 Busy하면 Source큐는 Target큐의 Job을 Steal(Work stealing, Migration).</li>\n</ul>","frontmatter":{"title":"[OS] Multiprocessor Scheduling","date":"July 06, 2021"}}},"pageContext":{"slug":"/CS/MultiprocessorScheduling/","previous":{"fields":{"slug":"/Hetero/Introduction of FPGA acceleration/"},"frontmatter":{"title":"[FPGA]Introduction of FPGA acceleration"}},"next":{"fields":{"slug":"/CS/LFS/"},"frontmatter":{"title":"[OS] Log-Structured File system"}}}}}