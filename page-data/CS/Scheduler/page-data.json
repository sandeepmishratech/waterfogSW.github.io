{"componentChunkName":"component---src-templates-blog-post-js","path":"/CS/Scheduler/","result":{"data":{"site":{"siteMetadata":{"title":"For The Record","author":"San Kim","siteUrl":"https://waterfogsw.github.io","comment":{"disqusShortName":"","utterances":"waterfogSW/waterfogSW.github.io"}}},"markdownRemark":{"id":"1ab54ca7-80ee-53cc-8f2f-52c2a0104296","excerpt":"CPU Scheduling 많은 프로세스가 동시에 자원을 요구할 때 어떤 프로세스가 CPU를 먼저 사용할지 결정하는 정책을 말합니다. Workload (작업부하) 프로세스가 얼마나 많은 양의 자원을 요구하느냐 Simple assumtion about porcess 각 작업은 같은 시간동안 수행된다 모든 작업은 같은 시간에 시작된다 한번 시작되면 완료될때 까지 실행된다 모든 작업은 CPU만을 사용한다. 각 작업의 수행시간을 미리 알고 있다. Job & Process…","html":"<h2 id=\"cpu-scheduling\" style=\"position:relative;\"><a href=\"#cpu-scheduling\" aria-label=\"cpu scheduling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU Scheduling</h2>\n<p>많은 프로세스가 동시에 자원을 요구할 때 어떤 프로세스가 CPU를 먼저 사용할지 결정하는 정책을 말합니다.</p>\n<h2 id=\"workload-작업부하\" style=\"position:relative;\"><a href=\"#workload-%EC%9E%91%EC%97%85%EB%B6%80%ED%95%98\" aria-label=\"workload 작업부하 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Workload (작업부하)</h2>\n<ul>\n<li>프로세스가 얼마나 많은 양의 자원을 요구하느냐</li>\n</ul>\n<h3 id=\"simple-assumtion-about-porcess\" style=\"position:relative;\"><a href=\"#simple-assumtion-about-porcess\" aria-label=\"simple assumtion about porcess permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Simple assumtion about porcess</h3>\n<ul>\n<li>각 작업은 같은 시간동안 수행된다</li>\n<li>모든 작업은 같은 시간에 시작된다</li>\n<li>한번 시작되면 완료될때 까지 실행된다</li>\n<li>모든 작업은 CPU만을 사용한다.</li>\n<li>각 작업의 수행시간을 미리 알고 있다.</li>\n</ul>\n<p>Job &#x26; Process</p>\n<ul>\n<li>동일한 의미의 단어지만 스케줄러를 연구하는 도메인 에서는 job이라는 단어를 선호합니다.</li>\n</ul>\n<blockquote>\n<p><strong>프로세스</strong>(Process)는 주소공간을 가지고 있는 실행중인 프로그램을 말합니다</p>\n<p><strong>작업</strong>(job)은 셸에서 사용하는 개념으로 실행중인 대화형 프로그램을 말합니다. 데몬과 반대되는 개념입니다. 대화형 프로그램을 실행 중인 경우 ctrl + z키를 눌러 프로그램을 일시 중단할 수 있습니다.  </p>\n<p><strong>Deamon</strong> - 사용자가 직접적으로 제어하지 않고, 백그라운드에서 돌면서 여러 작업을 하는 프로그램입니다.</p>\n</blockquote>\n<h2 id=\"metric\" style=\"position:relative;\"><a href=\"#metric\" aria-label=\"metric permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Metric</h2>\n<p>성능, 의존성 등과 같은 것을 측정하기위한 척도</p>\n<h3 id=\"metric-for-scheduling\" style=\"position:relative;\"><a href=\"#metric-for-scheduling\" aria-label=\"metric for scheduling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Metric for Scheduling</h3>\n<ul>\n<li>\n<p>Turnaround time(반환시간, Complete time - Arrived time)</p>\n<ul>\n<li>처음 실행시간부터 작업을 완료하는데 소요된 시간(CPU, waiting, I/O 등 모든 시간을 포함)</li>\n</ul>\n</li>\n<li>\n<p>Response time(응답시간, First run time - Arrived time)</p>\n<ul>\n<li>처음 실행시간부터 작업이 응답하기까지 소요된 시간</li>\n</ul>\n</li>\n<li>\n<p>Fairness(형평성)</p>\n<ul>\n<li>두개의 프로세스가 종료되는 시간이 얼마나 비슷한지</li>\n</ul>\n</li>\n<li>\n<p>Throughput(처리율, jobs/sec)</p>\n<ul>\n<li>단위시간당 처리하는 작업의 수(처리량)</li>\n</ul>\n</li>\n<li>\n<p>Deadline(마감시간)</p>\n<ul>\n<li>Turnaround time &#x3C; Deadline time</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"response-time응답시간\" style=\"position:relative;\"><a href=\"#response-time%EC%9D%91%EB%8B%B5%EC%8B%9C%EA%B0%84\" aria-label=\"response time응답시간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Response time(응답시간)</h2>\n<p><strong>Turnaround time</strong> - Time required for a particular process to complete, from submission time to completion. It is equal to the sum total of Waiting time and Execution time.<br>\n-> batch 시스템에서 유리</p>\n<p><strong>Response time</strong> - The time taken in a program from the issuance of a command to the commence of a response to that command.(i.e., the time-interval between submission of a request, and the first response to that request, not the output .)<br>\n-> interactive 시스템에서 유리</p>\n<h2 id=\"fifofirst-in-first-out\" style=\"position:relative;\"><a href=\"#fifofirst-in-first-out\" aria-label=\"fifofirst in first out permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FIFO(First In First Out)</h2>\n<p>처음으로 도착한 프로세스를 먼저 스케줄링하는 정책(a.k.a FCFS(First Come First Serve))</p>\n<ul>\n<li>Pros : 1) 간단하다 2) 구현하기 쉽다</li>\n<li>Cons : 1) 대기시간이 길어질 수 있다. (convoy effect)</li>\n</ul>\n<blockquote>\n<p>Convoy Effect -  The whole Operating System slows down due to few slow processes</p>\n</blockquote>\n<h2 id=\"sjfshortest-job-first\" style=\"position:relative;\"><a href=\"#sjfshortest-job-first\" aria-label=\"sjfshortest job first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SJF(Shortest Job First)</h2>\n<p>수행시간이 가장 짧은 작업에 높은 우선순위를 부여(a.k.a SPN(Shortest Process Next))</p>\n<ul>\n<li>Pros : 최적의 알고리즘으로 증명됨</li>\n<li>Cons : 짧은 수행시간의 작업이 늦게 도착했을때 어떻게 하나?</li>\n</ul>\n<h2 id=\"stcfshortest-time-to-completion-first\" style=\"position:relative;\"><a href=\"#stcfshortest-time-to-completion-first\" aria-label=\"stcfshortest time to completion first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STCF(Shortest Time to Completion First)</h2>\n<p>SJF와 유사하나 선점형(Preemptive) 스케줄링 방식입니다</p>\n<p>Non-preemptive Scheduling(비선점형 스케줄링)</p>\n<ul>\n<li>프로세스가 한번 스케줄 되면 그 프로세스가 끝날때까지 수행합니다.</li>\n</ul>\n<p>Preemptive Scheduling(선점형 스케줄링)</p>\n<ul>\n<li>프로세스가 완료되지 않더라도 중간에 멈추고 다른 프로세스가 끼어들 수 있는 스케줄링 방식입니다.</li>\n<li>context switch가 요구됩니다.</li>\n<li>최근 모든 스케줄러는 선점형 스케줄링 방식을 사용합니다</li>\n</ul>\n<h2 id=\"response-time\" style=\"position:relative;\"><a href=\"#response-time\" aria-label=\"response time permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Response time</h2>\n<ul>\n<li>Turnaround time : batching 시스템에서 유리한 metric</li>\n<li>Response time : interactive 시스템에서 중요한 metric(ex, 대화형 쉘에서 프로그램을 실행했는데 늦게 실행되면 답답)</li>\n</ul>\n<h2 id=\"rrround-robin\" style=\"position:relative;\"><a href=\"#rrround-robin\" aria-label=\"rrround robin permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RR(Round Robin)</h2>\n<p>Run queue의 작업이 완료될때 까지 <strong>Time quantum</strong>만큼 빠르게 돌아가며 수행<br>\n-> Response Time 단축, Turnaround time 증가</p>\n<h3 id=\"tradeoff-of-time-slicetime-quantum\" style=\"position:relative;\"><a href=\"#tradeoff-of-time-slicetime-quantum\" aria-label=\"tradeoff of time slicetime quantum permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tradeoff of time slice(time quantum)</h3>\n<ul>\n<li>Samll : 높은 응답 속도, Context switch로 인한 오버헤드 증가</li>\n<li>Large : 낮은 응답 속도, Context switch로 인한 오버헤드 감소</li>\n</ul>\n<p>-> time quantum의 크기가 커질수록 FCFS와 동일하게 동작하며 0에 가까울수록 switching overhead가 증가하여 비효율적입니다. </p>\n<h3 id=\"tradeoff-of-between-response-time-and-turnaround-time\" style=\"position:relative;\"><a href=\"#tradeoff-of-between-response-time-and-turnaround-time\" aria-label=\"tradeoff of between response time and turnaround time permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tradeoff of between response time and turnaround time</h3>\n<ul>\n<li>Traditional isuue in CS : Interactivity(응답속도) vs Performance(성능)</li>\n<li>두마리 토끼를 동시에 잡을수는 없다</li>\n</ul>\n<h2 id=\"incorporating-io\" style=\"position:relative;\"><a href=\"#incorporating-io\" aria-label=\"incorporating io permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Incorporating I/O</h2>\n<p>프로세스로 부터 입출력 요청이 있을때 프로세스는 입출력이 완료될 때 까지 기다려야 합니다. </p>\n<ul>\n<li>Busy waiting : 프로세스 A의 I/O가 수행되는동안 상태 확인, CPU자원 낭비</li>\n<li>Blocked : 프로세스 A의 I/O가 수행되는동안 프로세스 B를 스케줄 하여 자원 낭비를 최소화</li>\n</ul>\n<h2 id=\"mlfomultilevel-feedback-queue\" style=\"position:relative;\"><a href=\"#mlfomultilevel-feedback-queue\" aria-label=\"mlfomultilevel feedback queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MLFO(Multilevel Feedback Queue)</h2>\n<ul>\n<li>선점형 스케줄링 방식으로 여러개의 Ready Queue에 사용</li>\n<li>각 Queue마다 다른 Priority level 을 부여받음</li>\n<li>\n<p>높은 우선순위의 Queue가 먼저 스케줄되며, 같은 queue내에서는 RR방식 적용합ㄴ디ㅏ</p>\n<ul>\n<li>Rule 1 : Priority(A) > Priority(B) 일때 A가 먼저 수행합니다.</li>\n<li>Rule 2 : Priority(A) = Priority(B) 일때 라운드 로빈 방식으로 수행합니다.</li>\n<li>Rule 3 : Job이 들어오면 가장 상위 Ready Queue에 할당합니다.</li>\n<li>Rule 4a : 할당된 Time slice(time quantum)가 끝나면 하위 Queue로 우선순위가 내려갑니다.</li>\n<li>Rule 4b : Time slice가 끝나기전 스케줄링이 해제 동일한 우선순위 레벨에 남습니다.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[OS] Scheduler","date":"March 14, 2021"}}},"pageContext":{"slug":"/CS/Scheduler/","previous":{"fields":{"slug":"/CS/Ramdisk, Disk성능비교/"},"frontmatter":{"title":"[OS] RAM disk vs Disk Performance evaluation"}},"next":{"fields":{"slug":"/OpenSource/RDBIntro/"},"frontmatter":{"title":"[RocksDB] Introduction"}}}}}